<!doctype html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Pixi Test</title>
</head>

<body>
	<div id="px-render"></div>

	<script src="pixi/pixi.min.js"></script>

	<script>

		let Application = PIXI.Application,
			Container = PIXI.Container,
			loader = PIXI.loader,
			resources = PIXI.loader.resources,
			Graphics = PIXI.Graphics,
			TextureCache = PIXI.utils.TextureCache,
			Sprite = PIXI.Sprite,
			Text = PIXI.Text,
			TextStyle = PIXI.TextStyle,
			Point = PIXI.Point;

		let option = {
			width: 600,
			height: 600,
			transparent: true,
			antialias: true,
			resolution: 1
		}

		let style = new TextStyle({
			fontFamily: "Arial",
			fontSize: 18,
			fill: "white",
			stroke: '#ff3300',
			strokeThickness: 4,
		});

		class Grid {
			position;
			block;
			supply;
			constructor(position) {
				this.position = position;
			}
		}

		class gridBackground {
			map;

			constructor(size) {
				this.map = new Array(size.x);
				for (let i = 0; i < size.x; i++) {
					this.map[i] = new Array(size.y);
					for (let j = 0; j < size.y; j++) {
						let textNumber = (i * size.x) + j;

						this.map[i][j] = new Grid(new Point(j * defaultUnit, i * defaultUnit));

						cubeContainer[textNumber] = app.stage.addChild(new Container());
						cubeContainer[textNumber].position = new Point(j * defaultUnit, i * defaultUnit);
						cubeContainer[textNumber].name = "back " + textNumber;

						cube = new PIXI.Graphics();
						if (textNumber == 0) {
							cube.beginFill(0x46A3FF);
						} else {
							cube.beginFill(0xfcba03);
						}

						cube.lineStyle(1, 0xFF3300, 1);
						cube.drawRect(0, 0, defaultUnit, defaultUnit);
						cube.endFill();

						cubeContainer[textNumber].interactive = true;
						cubeContainer[textNumber]
							.on('mousedown', onDragMove)


						cubeNumber = new Text(textNumber, style);
						cubeNumber.position.x = (cube.width - cubeNumber.width) / 2;
						cubeNumber.position.y = (cube.height - cubeNumber.height) / 2;

						cubeContainer[textNumber].addChild(cube);
						cubeContainer[textNumber].addChild(cubeNumber);

						temporaryCubeArray.push(new Point(cubeContainer[textNumber].position.x, cubeContainer[textNumber].position.y));
						correctCubeArray.push(new Point(cubeContainer[textNumber].position.x, cubeContainer[textNumber].position.y));
					}
				}
			}

			getGrid(point) {
				return cubeContainer['0'].position;
			}
		}

		let app = new Application(option);
		let defaultUnit = 60;
		document.body.appendChild(app.view);

		let defaultCube = new Array();

		let temporaryCubeArray = new Array(0);
		let correctCubeArray = new Array(0);
		let gridSystem;

		let cubeContainer = new Array();
		let cubeNumber;
		let cube;

		let gameInfoText;
		let state

		this.setup();

		function gameLoop(delta) {
			state(delta);
		}

		function setup() {
			gridSystem = new gridBackground(new Point(2, 2));
			randomArrange();
			app.ticker.add(this.gameLoop.bind(this));
			state = play;
		}

		function play() {

			if (cubeContainer[1].transform.position == (60, 0)) {
				console.error('win');
				state = Win;
			}
		}

		function onDragMove() {
			let newPosition = gridSystem.getGrid('0');
			if ((this.position.x - newPosition.x) * (this.position.x - newPosition.x) +
				(this.position.y - newPosition.y) * (this.position.y - newPosition.y) == defaultUnit * defaultUnit) {
				let temporaryPosition = new Point(this.position.x, this.position.y);
				this.position = newPosition;
				cubeContainer['0'].position = temporaryPosition;
			}

		}

		function randomArrange() {
			for (i = 0; i < cubeContainer.length; i++) {
				let random = Math.floor(Math.random() * temporaryCubeArray.length);
				cubeContainer[i].position = temporaryCubeArray[random];
				temporaryCubeArray.splice(random, 1);
			}
		}

		function Win() {
			console.error(" Win ");
			gameInfoText.text = " Win ", style;
			gameInfoText.position = new Point((app.renderer.view.width - gameInfoText.width) / 2,
				(app.renderer.view.height - gameInfoText.height) / 2);

		}
	</script>
</body>

</html>